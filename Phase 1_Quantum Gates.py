# -*- coding: utf-8 -*-
"""Report_EE_225_Final_Phase1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15grHQfQ8LMPA7TUbahFlKhuHfXe5rRJ4

#EE 225: Introduction to Quantum Computing 
#Final Project: Phase 1 (Quantum Gates)
#MSEE San Jose State University 
# Hector Jose Morrell Jr

#Summary

In Quantum Computing and especially in quantum circuitry, Quantum Gates are the fundamantal functions we use for operating on Qubits. Qubits are are the basic unit of quantum information, similarly to the binary bit in classical computers with 2 states.

Just like classical computers, quantum gates are placed on qubits to perform an operation, the difference between the quantum gate and classical gates is that quantum gates are reversable. These gates being reversible is an advantage given the fact that if needed we could take an output and find out what the input waveform is so that we can see the properties of that qubit. 

In this project we will be writing functions for several quantum gates: NOT gate, XOR gate, SWAP gate, 1 -bit phase shift gate, 2-bit  phase  shift  gate,  Toffoli  gate,  and  5-bit  Hadamard  gate. The gates need to be able to take any input(decimal, integer, negative, positive) and be able to perform the operation.  

  Below is a list of the quantum gates that were used in this report and a brief explanation of what each gate does.  

1.   NOT Gate: The purpose of the NOT gate is similar to the inverter in classical computing where it will invert the bit. 

2.   XOR(Controll Not) Gate: Controlled gates act on 2 qubits, where one qubit act as a control for another qubit and the control is intended to invert the controlled bit. 

3.   Phase Shift: The Phase Shift gate is intended to rotate bits a certain phase. The phase shift in this code can be changed but was decided to be (pi/4). The phase shift of (pi/4) was chosen because a phase shift of (pi) would cause e^(i*theta) to become -1, which is the same as the Pauli-Z matrix. 

4.   SWAP Gate: The SWAP gate simply swaps the states of two qubits.

5.   Toffoli Gate: Has two control qubits and one target.  The Toffoli is a Control-Control not. So the third qubit will only change when both control bits are 1. 

6. Hadamard Gate: The Hadamard gate acts on a single bit mapping it and making it a superposition of either |1> or |0>. It is a rotational measurement across the axis of a Bloch Sphere.


  This simulator for the gates does have the input waveforms hard coded in, all you need to do is compile the code and it will give you the expected results. For any waves forms you would like to change please refer to the gate you are wanting to use and change the waveforms constants as pleased.

#Expedected Results

1.   Not Gate: 

            |1> ---> |0>
            |0> ---> |1>

2.   XOR(Controll Not) Gate:  

            |00> ---> |00>
            |01> ---> |01>
            |10> ---> |11>
            |11> ---> |10>

3.   SWAP Gate: 

            |00> ---> |00>
            |01> ---> |10>
            |10> ---> |01>
            |11> ---> |11>

4.   Phase Shift: 

            i = phase shift of e^(i*theta)

            1-Bit
            |0> ---> |0>
            |1> ---> (i)|1>

            2-Bit
            |00> ---> |00>
            |01> ---> (i)|01>
            |10> ---> (i)|10>
            |11> ---> (-1)|11>

5.   Toffoli Gate: 

            |000> ---> |000>
            |001> ---> |001>
            |010> ---> |010>
            |011> ---> |011>
            |100> ---> |100>
            |101> ---> |101>
            |110> ---> |111>
            |111> ---> |110>

6. Hadamard Gate: This expected results will be applied to each individual bits.  

          |0> ---> (1/sqrt(2))[|0> + |1>]
          |1> ---> (1/sqrt(2))[|0> - |1>]

# Code

Below is the code used for the Qunatum Gate Outputs.

##Not Gate

The Not gate below has has the ability to perform both a 1 qubit and 2 qubit function. 

For the 1 qubit the input is a 2x1 Vector with R1 being the first row and R2 being the second row of the matrix

For the 2 qubit the input is a 4x1 Vector with R4 being the first row and then R5, R6, R7 being the subsequent rows.

If you would like to compute a different Vector please change the below in the code.
"""

import numpy as np
from numpy.ma import exp
from math import sqrt


''' This function is to determine the output after using NOT Gate '''


def not_gate():
    print('\nTHIS SECTION IS NOT GATE')
    # Defining the NOT Gate
    NOT_1bit = [[0, 1],
                [1, 0]]
    NOT_2bit = [[0, 0, 0, 1],
                [0, 0, 1, 0],
                [0, 1, 0, 0],
                [1, 0, 0, 0]]

    # Declaration statement to redirect to appropriate Qubit calculation


    # Below line read inputs from user
    R1 = -.707
    R2 = 0
    print("\n""Vector is - ", "\n", R1, "\n", R2)


    # Setting List as an Array
    Matrix1 = np.array([R1, R2])
    print("\n""Vector", Matrix1)

    # The function to Multiply the Matrices
    NOT_GATE_OUT1 = Matrix1.dot(NOT_1bit)
    print("NOT Gate Output", NOT_GATE_OUT1)


    # Below line read inputs from user
    R4 = .707
    R5 = 0
    R6 = .707
    R7 = 0
    print("\n""Vector is - ", "\n", R4, "\n", R5, "\n", R6, "\n", R7)


    # Setting List as an Array
    Matrix = np.array([R4, R5, R6, R7])
    print("\n""Vector", Matrix)

    # The function to Multiply the Matrices
    NOT_GATE_OUT = Matrix.dot(NOT_2bit)
    print("NOT Gate Output", NOT_GATE_OUT)

not_gate()

"""##XOR GATE(CNOT)

The XOR(CNOT) gate below has has the ability to perform a 2 qubit function. 

For 2 qubit, the input is a 4x1 vector with R1 being the first row and then R2, R3, R4 being the subsequent rows.

If you would like to compute a different vector please change the below in the code.
"""

import numpy as np
from numpy.ma import exp
from math import sqrt

def XOR_GATE():
    print('\n\nTHIS SECTION IS XOR(CNNOT) GATE')
    # Defining the XOR Gate
    CNOT_2bit = [[1, 0, 0, 0],
                 [0, 1, 0, 0],
                 [0, 0, 0, 1],
                 [0, 0, 1, 0]]

    # Informing user of the matrices size
    print("\nYou have Selected the XOR(CNOT)\nThe Vector Required is a 4x1")


    # Below line read inputs
    R1 = -.707
    R2 = 0
    R3 = .707
    R4 = 0
    print("\n""Vector is - ", "\n", R1, "\n", R2, "\n", R3, "\n", R4)


    # Setting List as an Array
    Matrix = np.array([R1, R2, R3, R4])
    print("\nInput - Vector", Matrix)

    # Function to Multiply the Matrices
    CNOT_GATE_OUT = Matrix.dot(CNOT_2bit)
    print("XOR Gate Output", CNOT_GATE_OUT)

XOR_GATE()

"""##SWAP GATE

The SWAP gate below has has the ability to perform a 2 qubit function. 

For 2 qubit, the input is a 4x1 matrix with R1 being the first row and then R2, R3, R4 being the subsequent rows.

If you would like to compute a different vector please change the below in the code.
"""

import numpy as np
from numpy.ma import exp
from math import sqrt

'''This function is to determine the output after using SWAP Gate'''


def SWAP_GATE():
    print('\n\nTHIS SECTION IS SWAP GATE')
    # Defining the XOR Gate
    SWAP = [[1, 0, 0, 0],
            [0, 0, 1, 0],
            [0, 1, 0, 0],
            [0, 0, 0, 1]]

    # Informing user of the matrices siz
    print("\nYou have Selected the SWAP Gate\nThe vector Required is a 4x1")


    # Below line read inputs from user
    R1 = -.707
    R2 = 0
    R3 = .707
    R4 = 0
    print("\n""Vector is - ", "\n", R1, "\n", R2, "\n", R3, "\n", R4)


    # Setting List as an Array
    Matrix = np.array([R1, R2, R3, R4])
    print("\n""Input - Vector", Matrix)

    # Multiplying Matrices
    SWAP_OUT = Matrix.dot(SWAP)
    print("SWAP Gate Output", SWAP_OUT)


SWAP_GATE()

"""##Phase Shift

The Not gate below has has the ability to perform both a 1 qubit and 2 qubit function. 

For the 1 qubit the input is a 2x1 matrix with R1 being the first row and R2 being the second row of the matrix

For the 2 qubit the input is a 4x1 matrix with R3 being the first row and then R4, R5, R6 being the subsequent rows.

If you would like to compute a different vector please change the below in the code.
"""

import numpy as np
from numpy.ma import exp
from math import sqrt

def Phase_Shift():
    print('\n\nTHIS SECTION IS Phase Shift GATE')
    # Setting variable of z as an imaginary number if j
    z = 1j


    # Setting Varibale theta for the phase shift of system
    theta = np.pi / 6


    # Setting i as varibale for Phase Shift Matrix
    i = exp(theta * z)

    # Defining the NOT Gate
    Phase_1bit = [[1, 0], 
                  [0, i]]
    Phase_2bit = [[1, 0, 0, 0],
                  [0, 1, 0, 0],
                  [0, 0, 1, 0],
                  [0, 0, 0, i]]


    # Below line read inputs from user
    R1 = -.707
    R2 = 0
    print("\n""1-Bit Vector is - ", "\n", R1, "\n", R2)
    Matrix1 = np.array([R1, R2])
    print("\n""Vector", Matrix1)



    Phase_GATE_OUT = Matrix1.dot(Phase_1bit)
    print("Phase Gate Output", Phase_GATE_OUT)

    
    # Below line read inputs from user
    R3 = .707
    R4 = 0
    R5 = .707
    R6 = 0
    print("\n""2-Bit Vector is - ", "\n", R3, "\n", R4, "\n", R5, "\n", R6)
    Matrix = np.array([R3, R4, R5, R6])
    print("\n""Input - Vector", Matrix)


    Phase2_GATE_OUT = Matrix.dot(Phase_2bit)
    print("2-Bit Phase Gate Output", Phase2_GATE_OUT)

Phase_Shift()

"""##Toffoli Gate

The Toffoli gate below has has the ability to perform a 3 qubit function. 

For the 3 qubit the input is a 8x1 matrix with R1 being the first row and then R2-R8 being the subsequent rows.

If you would like to compute a different vector please change the below in the code.
"""

import numpy as np
from numpy.ma import exp
from math import sqrt

def Toffoli_GATE():
    print('\n\nTHIS SECTION IS Toffoli GATE')
    # Defining the Toffoli Gate
    Toffoli_bit = [[1, 0, 0, 0, 0, 0, 0, 0],
                   [0, 1, 0, 0, 0, 0, 0, 0],
                   [0, 0, 1, 0, 0, 0, 0, 0],
                   [0, 0, 0, 1, 0, 0, 0, 0],
                   [0, 0, 0, 0, 1, 0, 0, 0],
                   [0, 0, 0, 0, 0, 1, 0, 0],
                   [0, 0, 0, 0, 0, 0, 0, 1],
                   [0, 0, 0, 0, 0, 0, 1, 0]]

    # Informing user of the elements needed for this gate
    print("\nYou have Selected the Toffoli Gate\nThe vector Required is a 8x1")



    # Below line read inputs from user
    R1 = -.707
    R2 = 0
    R3 = .707
    R4 = 0
    R5 = .707
    R6 = 0
    R7 = .707
    R8 = 0
    print("\n""Vector is - ", "\n", R1, "\n", R2, "\n", R3, "\n", R4, "\n", R5, "\n", R6, "\n", R7, "\n", R8)



    # Setting Matrix as an Array
    Matrix = np.array([R1, R2, R3, R4, R5, R6, R7, R8])
    print("\n""Input - Vector", Matrix)

    # Matrix multiplication of the user input and Toffoli Gate
    Toffoli_GATE_OUT = Matrix.dot(Toffoli_bit)
    print("Toffoli Gate Output", Toffoli_GATE_OUT)

Toffoli_GATE()

"""##Hadamard Gate

The Hadamard gate below has has the ability to perform a 5 qubit function. 

For the 5 qubit the input is a 32x1 matrix with R1 being the first row and then R2-R32 being the subsequent rows.

If you would like to compute a different vector please change the below in the code.
"""

import numpy as np
from numpy.ma import exp
from math import sqrt

def Hadamard_Gate():
    print('\n\nTHIS SECTION IS 5-Bit Hadamard GATE')
    # Defining the H Gate
    H = [([1 / sqrt(2), 1 / sqrt(2)], 
          [1 / sqrt(2), -1 / sqrt(2)])]

    print('\nThis is the Hadamard Gate', '\n', H)

    # Iterative tensor product to determine the 5-Qubit Hadamard Gate
    H_2 = np.kron(H, H)
    H_3 = np.kron(H_2, H)
    H_4 = np.kron(H_3, H)
    H_Tensor = np.kron(H_4, H)

    print('\nThis is the 5-Bit Hadamard Gate', '\n', H_Tensor)

    # Informing user of the number of elements in this system
    print("\nYou have selcted the 5-Bit Hadamard Gate \nThe Vector Required is a 32x1")



    # Below line read inputs from user
    R1 = 1
    R2 = 0
    R3 = 0
    R4 = 0
    R5 = 0
    R6 = 0
    R7 = 0
    R8 = 0
    R9 = 0
    R10 = 0
    R11 = 0
    R12 = 0
    R13 = 0
    R14 = 0
    R15 = 0
    R16 = 0
    R17 = 0
    R18 = 0
    R19 = 0
    R20 = 0
    R21 = 0
    R22 = 0
    R23 = 0
    R24 = 0
    R25 = 0
    R26 = 0
    R27 = 0
    R28 = 0
    R29 = 0
    R30 = 0
    R31 = 0
    R32 = 0


    print("\n""Vector is - ", "\n", R1, "\n", R2, "\n", R3, "\n", R4, "\n", R5, "\n", R6, "\n", R7, "\n", R8,
          "\n", R9, "\n", R10, "\n", R11, "\n", R12, "\n", R13, "\n", R14, "\n", R15, "\n", R16,
          "\n", R17, "\n", R18, "\n", R19, "\n", R20, "\n", R21, "\n", R22, "\n", R23, "\n", R24,
          "\n", R25, "\n", R26, "\n", R27, "\n", R28, "\n", R29, "\n", R30, "\n", R31, "\n", R32)

    # Setting matrix as an array
    Matrix = np.array([R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13, R14, R15, R16, R17, R18, R19, R20,
                       R21, R22, R23, R24, R25, R26, R27, R28, R29, R30, R31, R32])
    print("\n""Input - Vector", Matrix)

    # Matrix Multiplication
    H_GATE_OUT = Matrix.dot(H_Tensor)
    print("\n""5-Bit Hadamard Gate Output", H_GATE_OUT)

Hadamard_Gate()

"""# Results

The results of my code were conclusive that everything is working properly and according to design. The functions were able to take any input regardless whether they were decimals, integers, positive or negative, and were able to perform the necessary function designed for.  

The NOTE Gate results were resulting in the states being swapped |0> ---> |1> or |1> ---> |0>. The qubits were effectively inverted.

The XOR(CNOT) would effectively use the control bit to swap the state of the second bit. |11> ---> |10> or |10> ---> |11>, while leaving the other states unchanged.

The SWAP Gate was able to effectively swap the bits, |01> ---> |10> and |10> ---> |01>, while leaving the other states unchanged.  

The Phase Shift was able to successfully shift the bit of interest a certain phase that was determined by the use. For this report it was shifted for the (pi/4), this was picked because a phase shift of (pi) would cause e^(i*theta) to become -1, which is the same as the Pauli-Z matrix.  

The Toffoli also known as the CCNOT gate, Control-Control Not gate, which will swap the third bit if both the control bits are 1. For the simulation the the following states inverterd the third bit, |111> and |110>.  

The 5-Bit Hadamard would place each individual bits into a superposition of |0> and |1>. For the Hadamard Gate since it was a 5-Bit the way to obtain this 32x32 matrix was to Tensor product 5 1-Hadamard gate to make the 5-Bit Hadamard gate. When testing the Hadamard Gate, I inputeda a 32x1 Matrix consisting of the first row being 1 and the rest being 0. The expected output would be a 32x1 matrix with all the rows consisting of .176, which is exactly what is reported. Concluding that the Hadamard gate is working correctly.

# Conclusion

This project was effective in teaching how to implement quantum gates without the need of programs such as IBMQ. This code is just the beginning, we will be using it as the stepping stone to not only Phase 2 of this project, which is Implement Deutsch’s Algorithm, but also to a more refined and broader function. An idea I want to pursue is to make this code dynamic and able to take more qubits so that I could be used for more quantum Circuit/Computing functions.
"""